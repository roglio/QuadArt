/* QuadArt 2.0 - cooperative tiled led matrix display project       */
/* this program converts a picture into a .h file to be included in */
/* embedded projects like an Arduino based driver for led matrix    */
/* credits for the original version goes to: Markus Lipp            */
/* http://forums.adafruit.com/viewtopic.php?f=47&t=50115            */
/* starting from the original version I added the ability to resize */
/* the image, handle animated gif images and output a RGB 444 bit   */
/* packed format, more suitable for small microcontrollers          */
/* 2015/10/05 leandro.zaccaria@gmail.com CC BY-SA 3.0 for AUGC      */
/* https://www.facebook.com/groups/1376364222668338/                */

import gifAnimation.*;

PImage[] animation;

PImage image;
String imgName;
PrintWriter outputMatrix;

void setup() {
  selectInput("Select a file to process:", "imageName");
}

void imageName(File selection) {
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
    exit();
  }
  else {
    println("User selected " + selection.getAbsolutePath());
    imgName = selection.getAbsolutePath();
    animation = Gif.getPImages(this, imgName);
    background(0, 0, 0);

    outputMatrix = createWriter("image444.h");

    outputMatrix.println("// Generated by Processing script");
    outputMatrix.println("// Original file: " + imgName);
    outputMatrix.println("#include <avr/pgmspace.h>");
    outputMatrix.println("");

    for(int l=0;l<animation.length;l++) {
     
      image = animation[l];
      if(image.width >32 || image.height >32) {
        image.resize(32,0);
      }
      image(image, 0, 0);

      outputMatrix.println("static const uint8_t PROGMEM frame_0x"+hex(l,2)+"[] = {");

      matrixbuff = new byte[1536];
  
      for (int y = 0; y < 32; y++) {
        for (int x = 0; x < 32; x++) {
  
          color tempColor = image.get(x, y);
          int r = tempColor >> 16 & 0xFF;
          int g = tempColor >> 8 & 0xFF;
          int b = tempColor & 0xFF;
          float alpha = alpha(tempColor);
  
          if (alpha != 255) tempColor=r=g=b=0;
  
          int c565 = Color888(r, g, b, true);

          drawPixel(x, y, c565, matrixbuff);
        }
      }
      
      for(int i=0;i<1536;i++) {
        if (i!=0 && i%32==0) {
          outputMatrix.println("");
        }
        byte c = matrixbuff[i];
        outputMatrix.print("0x" + hex(c, 2) + ",");
      }
      outputMatrix.println("};");
      outputMatrix.println();
      outputMatrix.flush();
    }

    outputMatrix.println("");    
    outputMatrix.println("static const uint8_t *image[] = {");
    for(int l=0;l<animation.length;l++) {
      if (l!=0 && l%8==0) {
        outputMatrix.println("");
      }
      outputMatrix.print("frame_0x"+hex(l,2)+", ");
    }
    outputMatrix.println("};");
    outputMatrix.println("");

    outputMatrix.flush();
    outputMatrix.close();
    println("Total frames: "+animation.length);
    println("Done!");
    exit();
  }
}

int Color565(int r, int g, int b) {
  return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

int Color888(int r, int g, int b, boolean gflag) {
  if(gflag) { // Gamma-corrected color?
    r = gamma[r]; // Gamma correction table maps
    g = gamma[g]; // 8-bit input to 4-bit output
    b = gamma[b];
    return (r << 12) | ((r & 0x8) << 8) | // 4/4/4 -> 5/6/5
           (g <<  7) | ((g & 0xC) << 3) |
           (b <<  1) | ( b        >>> 3);
  } // else linear (uncorrected) color
  return ((r & 0xF8) << 11) | ((g & 0xFC) << 5) | (b >>> 3);
}

static byte matrixbuff[];
static int nPlanes = 4;
static int nRows = 16;
static int WIDTH = 32;

static void drawPixel(int x, int y, int c, byte[] arr) {
  byte r, g, b, bit, limit;
  
  // Adafruit_GFX uses 16-bit color in 5/6/5 format, while matrix needs
  // 4/4/4. Pluck out relevant bits while separating into R,G,B:
  r = (byte)((c >>> 12) & 0xF); // RRRRrggggggbbbbb
  g = (byte)((c >>>  7) & 0xF); // rrrrrGGGGggbbbbb
  b = (byte)((c >>>  1) & 0xF); // rrrrrggggggBBBBb

  //r=4;g=0;b=0;
  // Loop counter stuff
  bit = 2;
  limit = (byte)(1 << nPlanes);

  int baseAddr;

  if (y < nRows) {

    baseAddr = y * WIDTH * (nPlanes - 1) + x;// ptr = &matrixbuff[backindex][y * WIDTH * (nPlanes - 1) + x]; // Base addr
    
    arr[baseAddr + 64] &= 252; // ptr[64] &= ~B00000011; // Plane 0 R,G
                  // mask out in one op
    if ((r & 1) != 0)
      arr[baseAddr + 64] |= 1;  // if(r & 1) ptr[64] |= B00000001; //
                    // Plane 0 R: 64 bytes ahead, bit 0
    if ((g & 1) != 0)
      arr[baseAddr + 64] |= 2;// if(g & 1) ptr[64] |= B00000010; //
                  // Plane 0 G: 64 bytes ahead, bit 1
    if ((b & 1) != 0)
      arr[baseAddr + 32] |= 1;// if(b & 1) ptr[32] |= B00000001; //
                  // Plane 0 B: 32 bytes ahead, bit 0
    else
      arr[baseAddr + 32] &= 254; // else ptr[32] &= ~B00000001; //
                    // Plane 0 B unset; mask out

    for (; bit < limit; bit <<= 1) {// for(; bit < limit; bit <<= 1) {
      arr[baseAddr] &= 227; ; // *ptr &= ~B00011100; // Mask out R,G,B in
                  // one op
      if ((r & bit) != 0)
        arr[baseAddr] |= 4; // if(r & bit) *ptr |= B00000100; //
                  // Plane N R: bit 2
      if ((g & bit) != 0)
        arr[baseAddr] |= 8; // if(g & bit) *ptr |= B00001000; //
                  // Plane N G: bit 3
      if ((b & bit) != 0)
        arr[baseAddr] |= 16; // if(b & bit) *ptr |= B00010000; //
                    // Plane N B: bit 4
      baseAddr += WIDTH; // Advance to next bit plane
    }
  } else {

    baseAddr = (y - nRows) * WIDTH * (nPlanes - 1) + x; // ptr = &matrixbuff[backindex][(y - nRows) * WIDTH * (nPlanes - 1) + x];
    
    arr[baseAddr] &=  252; // *ptr &= ~B00000011; // Plane 0 G,B mask out in one op
    
    if ((r & 1) != 0)
      arr[baseAddr + 32] |= 2; // if(r & 1) ptr[32] |= B00000010; //
                    // Plane 0 R: 32 bytes ahead, bit 1
    else
      arr[baseAddr + 32] &= 253; // else ptr[32] &= ~B00000010; //
                    // Plane 0 R unset; mask out
    if ((g & 1) != 0)
      arr[baseAddr] |= 1;// if(g & 1) *ptr |= B00000001; // Plane 0 G:
                // bit 0
    if ((b & 1) != 0)
      arr[baseAddr] |= 2;// if(b & 1) *ptr |= B00000010; // Plane 0 B:
                // bit 0

    for (; bit < limit; bit <<= 1) {
      // for(; bit < limit; bit <<= 1) {
      arr[baseAddr] &= 31; // *ptr &= ~B11100000; // Mask out R,G,B
                  // in one op
    if ((r & bit) != 0)
      arr[baseAddr] |= 32;// if(r & bit) *ptr |= B00100000; // Plane N
                // R: bit 5
    if ((g & bit) != 0)
      arr[baseAddr] |= 64;// if(g & bit) *ptr |= B01000000; // Plane N
                // G: bit 6
    if ((b & bit) != 0)
      arr[baseAddr] |= 128;// if(b & bit) *ptr |= B10000000; // Plane
                  // N B: bit 7
    baseAddr += WIDTH; // Advance to next bit plane
    }
  }
}

//C To Java conversion from Adafruit Matrix Library
static byte gamma[] = {
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,
      0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
      0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
      0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
      0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,
      0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
      0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
      0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x03,
      0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
      0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x04,
      0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
      0x04,0x04,0x04,0x04,0x04,0x04,0x05,0x05,
      0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
      0x05,0x05,0x05,0x06,0x06,0x06,0x06,0x06,
      0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x07,
      0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
      0x07,0x07,0x08,0x08,0x08,0x08,0x08,0x08,
      0x08,0x08,0x08,0x08,0x09,0x09,0x09,0x09,
      0x09,0x09,0x09,0x09,0x09,0x0a,0x0a,0x0a,
      0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0b,0x0b,
      0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0c,0x0c,
      0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0d,0x0d,
      0x0d,0x0d,0x0d,0x0d,0x0d,0x0e,0x0e,0x0e,
      0x0e,0x0e,0x0e,0x0e,0x0f,0x0f,0x0f,0x0f
    };
